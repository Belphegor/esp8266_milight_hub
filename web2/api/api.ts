/* tslint:disable */
/* eslint-disable */
/**
 * ESP8266 MiLight Hub
 * Official documention for MiLight Hub\'s REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: chris@sidoh.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface About
 */
export interface About {
    /**
     * Always set to \"milight-hub\"
     * @type {string}
     * @memberof About
     */
    'firmware'?: string;
    /**
     * Semver version string
     * @type {string}
     * @memberof About
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'ip_address'?: string;
    /**
     * Reason the system was last rebooted
     * @type {string}
     * @memberof About
     */
    'reset_reason'?: string;
    /**
     * Firmware variant (e.g., d1_mini, nodemcuv2)
     * @type {string}
     * @memberof About
     */
    'variant'?: string;
    /**
     * Amount of free heap remaining (measured in bytes)
     * @type {number}
     * @memberof About
     */
    'free_heap'?: number;
    /**
     * Version of Arduino SDK firmware was built with
     * @type {string}
     * @memberof About
     */
    'arduino_version'?: string;
    /**
     * 
     * @type {AboutQueueStats}
     * @memberof About
     */
    'queue_stats'?: AboutQueueStats;
}
/**
 * 
 * @export
 * @interface AboutQueueStats
 */
export interface AboutQueueStats {
    /**
     * Number of enqueued packets to be sent
     * @type {number}
     * @memberof AboutQueueStats
     */
    'length'?: number;
    /**
     * Number of packets that have been dropped since last reboot
     * @type {number}
     * @memberof AboutQueueStats
     */
    'dropped_packets'?: number;
}
/**
 * 
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     * 
     * @type {string}
     * @memberof Alias
     */
    'alias': string;
    /**
     * 
     * @type {number}
     * @memberof Alias
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Alias
     */
    'device_id': number;
    /**
     * 
     * @type {number}
     * @memberof Alias
     */
    'group_id': number;
    /**
     * 
     * @type {RemoteType}
     * @memberof Alias
     */
    'device_type': RemoteType;
}


/**
 * 
 * @export
 * @interface AliasesGet200Response
 */
export interface AliasesGet200Response {
    /**
     * 
     * @type {Array<Alias>}
     * @memberof AliasesGet200Response
     */
    'aliases'?: Array<Alias>;
    /**
     * 
     * @type {number}
     * @memberof AliasesGet200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AliasesGet200Response
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof AliasesGet200Response
     */
    'num_pages'?: number;
}
/**
 * 
 * @export
 * @interface AliasesIdPutRequest
 */
export interface AliasesIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AliasesIdPutRequest
     */
    'alias'?: string;
    /**
     * 
     * @type {number}
     * @memberof AliasesIdPutRequest
     */
    'device_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AliasesIdPutRequest
     */
    'group_id'?: number;
}
/**
 * 
 * @export
 * @interface AliasesPost201Response
 */
export interface AliasesPost201Response {
    /**
     * 
     * @type {number}
     * @memberof AliasesPost201Response
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface BooleanResponse
 */
export interface BooleanResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BooleanResponse
     */
    'success': boolean;
    /**
     * If an error occurred, message specifying what went wrong
     * @type {string}
     * @memberof BooleanResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface BulbId
 */
export interface BulbId {
    /**
     * 
     * @type {number}
     * @memberof BulbId
     */
    'device_id': number;
    /**
     * 
     * @type {number}
     * @memberof BulbId
     */
    'group_id': number;
    /**
     * 
     * @type {RemoteType}
     * @memberof BulbId
     */
    'device_type': RemoteType;
}


/**
 * Describes the current color mode of the bulb.  Useful for HomeAssistant. 
 * @export
 * @enum {string}
 */

export const ColorMode = {
    Brightness: 'brightness',
    Rgb: 'rgb',
    ColorTemp: 'color_temp',
    Onoff: 'onoff'
} as const;

export type ColorMode = typeof ColorMode[keyof typeof ColorMode];


/**
 * 
 * @export
 * @interface GatewayListItem
 */
export interface GatewayListItem {
    /**
     * 
     * @type {NormalizedGroupState}
     * @memberof GatewayListItem
     */
    'state': NormalizedGroupState;
    /**
     * 
     * @type {GatewayListItemDevice}
     * @memberof GatewayListItem
     */
    'device': GatewayListItemDevice;
}
/**
 * 
 * @export
 * @interface GatewayListItemDevice
 */
export interface GatewayListItemDevice {
    /**
     * 
     * @type {number}
     * @memberof GatewayListItemDevice
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof GatewayListItemDevice
     */
    'device_id': number;
    /**
     * 
     * @type {RemoteType}
     * @memberof GatewayListItemDevice
     */
    'device_type': RemoteType;
    /**
     * 
     * @type {number}
     * @memberof GatewayListItemDevice
     */
    'group_id': number;
    /**
     * 
     * @type {string}
     * @memberof GatewayListItemDevice
     */
    'alias': string;
}


/**
 * @type GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter
 * @export
 */
export type GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter = number | string;

/**
 * @type GatewaysDeviceIdRemoteTypeGroupIdPut200Response
 * @export
 */
export type GatewaysDeviceIdRemoteTypeGroupIdPut200Response = BooleanResponse | GroupState | NormalizedGroupState;

/**
 * 
 * @export
 * @interface GatewaysDeviceIdRemoteTypeGroupIdPutRequest
 */
export interface GatewaysDeviceIdRemoteTypeGroupIdPutRequest {
    /**
     * 
     * @type {State}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'state'?: State;
    /**
     * 
     * @type {State}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'status'?: State;
    /**
     * Color hue.  Will change bulb to color mode.
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'hue'?: number;
    /**
     * Color saturation.  Will normally change bulb to color mode.
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'saturation'?: number;
    /**
     * White temperature.  0 is coolest, 100 is warmest.
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'kelvin'?: number;
    /**
     * Alias for `kelvin`.
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'temperature'?: number;
    /**
     * White temperature measured in mireds.  Lower values are cooler.
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'color_temp'?: number;
    /**
     * Party mode ID.  Actual effect depends on the bulb.
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'mode'?: number;
    /**
     * 
     * @type {GroupStateColor}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'color'?: GroupStateColor;
    /**
     * Brightness on a 0-100 scale.
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'level'?: number;
    /**
     * Brightness on a 0-255 scale.
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'brightness'?: number;
    /**
     * 
     * @type {string}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'effect'?: GatewaysDeviceIdRemoteTypeGroupIdPutRequestEffectEnum;
    /**
     * Enables a transition from current state to the provided state. 
     * @type {number}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'transition'?: number;
    /**
     * 
     * @type {ColorMode}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'color_mode'?: ColorMode;
    /**
     * 
     * @type {GroupStateCommandsCommand}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'command'?: GroupStateCommandsCommand;
    /**
     * 
     * @type {Array<GroupStateCommand>}
     * @memberof GatewaysDeviceIdRemoteTypeGroupIdPutRequest
     */
    'commands'?: Array<GroupStateCommand>;
}

export const GatewaysDeviceIdRemoteTypeGroupIdPutRequestEffectEnum = {
    NightMode: 'night_mode',
    WhiteMode: 'white_mode'
} as const;

export type GatewaysDeviceIdRemoteTypeGroupIdPutRequestEffectEnum = typeof GatewaysDeviceIdRemoteTypeGroupIdPutRequestEffectEnum[keyof typeof GatewaysDeviceIdRemoteTypeGroupIdPutRequestEffectEnum];

/**
 * Group state
 * @export
 * @interface GroupState
 */
export interface GroupState {
    /**
     * 
     * @type {State}
     * @memberof GroupState
     */
    'state'?: State;
    /**
     * 
     * @type {State}
     * @memberof GroupState
     */
    'status'?: State;
    /**
     * Color hue.  Will change bulb to color mode.
     * @type {number}
     * @memberof GroupState
     */
    'hue'?: number;
    /**
     * Color saturation.  Will normally change bulb to color mode.
     * @type {number}
     * @memberof GroupState
     */
    'saturation'?: number;
    /**
     * White temperature.  0 is coolest, 100 is warmest.
     * @type {number}
     * @memberof GroupState
     */
    'kelvin'?: number;
    /**
     * Alias for `kelvin`.
     * @type {number}
     * @memberof GroupState
     */
    'temperature'?: number;
    /**
     * White temperature measured in mireds.  Lower values are cooler.
     * @type {number}
     * @memberof GroupState
     */
    'color_temp'?: number;
    /**
     * Party mode ID.  Actual effect depends on the bulb.
     * @type {number}
     * @memberof GroupState
     */
    'mode'?: number;
    /**
     * 
     * @type {GroupStateColor}
     * @memberof GroupState
     */
    'color'?: GroupStateColor;
    /**
     * Brightness on a 0-100 scale.
     * @type {number}
     * @memberof GroupState
     */
    'level'?: number;
    /**
     * Brightness on a 0-255 scale.
     * @type {number}
     * @memberof GroupState
     */
    'brightness'?: number;
    /**
     * 
     * @type {string}
     * @memberof GroupState
     */
    'effect'?: GroupStateEffectEnum;
    /**
     * Enables a transition from current state to the provided state. 
     * @type {number}
     * @memberof GroupState
     */
    'transition'?: number;
    /**
     * 
     * @type {ColorMode}
     * @memberof GroupState
     */
    'color_mode'?: ColorMode;
}

export const GroupStateEffectEnum = {
    NightMode: 'night_mode',
    WhiteMode: 'white_mode'
} as const;

export type GroupStateEffectEnum = typeof GroupStateEffectEnum[keyof typeof GroupStateEffectEnum];

/**
 * @type GroupStateColor
 * @export
 */
export type GroupStateColor = GroupStateColorOneOf | string;

/**
 * 
 * @export
 * @interface GroupStateColorOneOf
 */
export interface GroupStateColorOneOf {
    /**
     * 
     * @type {number}
     * @memberof GroupStateColorOneOf
     */
    'r'?: number;
    /**
     * 
     * @type {number}
     * @memberof GroupStateColorOneOf
     */
    'g'?: number;
    /**
     * 
     * @type {number}
     * @memberof GroupStateColorOneOf
     */
    'b'?: number;
}
/**
 * Commands that affect a given group.  Descriptiosn follow: * `pair`. Emulates the pairing process. Send this command right as you connect an unpaired bulb and it will pair with the device ID being used. * `unpair`. Emulates the unpairing process. Send as you connect a paired bulb to have it disassociate with the device ID being used. * `set_white`. Turns off RGB and enters WW/CW mode. * `night_mode`.  Most devices support a \"night mode,\" which has LEDs turned to a very dim setting -- lower than brightness 0. * `level_up`. Turns down the brightness. Not all dimmable bulbs support this command. * `level_down`. Turns down the brightness. Not all dimmable bulbs support this command. * `temperature_up`. Turns up the white temperature. Not all bulbs with adjustable white temperature support this command. * `temperature_down`. Turns down the white temperature. Not all bulbs with adjustable white temperature support this command. * `next_mode`. Cycles to the next \"disco mode\". * `previous_mode`. Cycles to the previous disco mode. * `mode_speed_up`. Turn transition speed for current mode up. * `mode_speed_down`. Turn transition speed for current mode down. * `toggle`. Toggle on/off state. 
 * @export
 * @enum {string}
 */

export const GroupStateCommand = {
    Unpair: 'unpair',
    Pair: 'pair',
    SetWhite: 'set_white',
    NightMode: 'night_mode',
    LevelUp: 'level_up',
    LevelDown: 'level_down',
    TemperatureUp: 'temperature_up',
    TemperatureDown: 'temperature_down',
    NextMode: 'next_mode',
    PreviousMode: 'previous_mode',
    ModeSpeedDown: 'mode_speed_down',
    ModeSpeedUp: 'mode_speed_up',
    Toggle: 'toggle'
} as const;

export type GroupStateCommand = typeof GroupStateCommand[keyof typeof GroupStateCommand];


/**
 * 
 * @export
 * @interface GroupStateCommands
 */
export interface GroupStateCommands {
    /**
     * 
     * @type {GroupStateCommandsCommand}
     * @memberof GroupStateCommands
     */
    'command'?: GroupStateCommandsCommand;
    /**
     * 
     * @type {Array<GroupStateCommand>}
     * @memberof GroupStateCommands
     */
    'commands'?: Array<GroupStateCommand>;
}
/**
 * @type GroupStateCommandsCommand
 * @export
 */
export type GroupStateCommandsCommand = GroupStateCommand | GroupStateCommandsCommandOneOf;

/**
 * 
 * @export
 * @interface GroupStateCommandsCommandOneOf
 */
export interface GroupStateCommandsCommandOneOf {
    /**
     * 
     * @type {string}
     * @memberof GroupStateCommandsCommandOneOf
     */
    'command'?: GroupStateCommandsCommandOneOfCommandEnum;
    /**
     * 
     * @type {TransitionArgs}
     * @memberof GroupStateCommandsCommandOneOf
     */
    'args'?: TransitionArgs;
}

export const GroupStateCommandsCommandOneOfCommandEnum = {
    Transition: 'transition'
} as const;

export type GroupStateCommandsCommandOneOfCommandEnum = typeof GroupStateCommandsCommandOneOfCommandEnum[keyof typeof GroupStateCommandsCommandOneOfCommandEnum];

/**
 * Defines a field which is a part of state for a particular light device.  Most fields are self-explanatory, but documentation for each follows: * `state` / `status` - same value with different keys (useful if your platform expects one or the other). * `brightness` / `level` - [0, 255] and [0, 100] scales of the same value. * `kelvin / color_temp` - [0, 100] and [153, 370] scales for the same value.  The later\'s unit is mireds. * `bulb_mode` - what mode the bulb is in: white, rgb, etc. * `color` / `computed_color` - behaves the same when bulb is in rgb mode.  `computed_color` will send RGB = 255,255,255 when in white mode.  This is useful for HomeAssistant where it always expects the color to be set. * `oh_color` - same as `color` with a format compatible with [OpenHAB\'s colorRGB channel type](https://www.openhab.org/addons/bindings/mqtt.generic/#channel-type-colorrgb-colorhsb). * `hex_color` - same as `color` except in hex color (e.g., `#FF0000` for red). * `device_id` / `device_type` / `group_id` - this information is in the MQTT topic or REST route, but can be included in the payload in the case that processing the topic or route is more difficult. 
 * @export
 * @enum {string}
 */

export const GroupStateField = {
    State: 'state',
    Status: 'status',
    Brightness: 'brightness',
    Level: 'level',
    Hue: 'hue',
    Saturation: 'saturation',
    Color: 'color',
    Mode: 'mode',
    Kelvin: 'kelvin',
    ColorTemp: 'color_temp',
    BulbMode: 'bulb_mode',
    ComputedColor: 'computed_color',
    Effect: 'effect',
    DeviceId: 'device_id',
    GroupId: 'group_id',
    DeviceType: 'device_type',
    OhColor: 'oh_color',
    HexColor: 'hex_color'
} as const;

export type GroupStateField = typeof GroupStateField[keyof typeof GroupStateField];


/**
 * 
 * @export
 * @enum {string}
 */

export const LedMode = {
    False: 'false',
    SlowToggle: 'Slow toggle',
    FastToggle: 'Fast toggle',
    SlowBlip: 'Slow blip',
    FastBlip: 'Fast blip',
    Flicker: 'Flicker',
    True: 'true'
} as const;

export type LedMode = typeof LedMode[keyof typeof LedMode];


/**
 * Group state with a static set of fields
 * @export
 * @interface NormalizedGroupState
 */
export interface NormalizedGroupState {
    /**
     * 
     * @type {string}
     * @memberof NormalizedGroupState
     */
    'alias'?: string;
    /**
     * 
     * @type {State}
     * @memberof NormalizedGroupState
     */
    'state'?: State;
    /**
     * 
     * @type {NormalizedGroupStateColor}
     * @memberof NormalizedGroupState
     */
    'color'?: NormalizedGroupStateColor;
    /**
     * 
     * @type {number}
     * @memberof NormalizedGroupState
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof NormalizedGroupState
     */
    'kelvin'?: number;
    /**
     * 
     * @type {ColorMode}
     * @memberof NormalizedGroupState
     */
    'color_mode'?: ColorMode;
}


/**
 * 
 * @export
 * @interface NormalizedGroupStateColor
 */
export interface NormalizedGroupStateColor {
    /**
     * 
     * @type {number}
     * @memberof NormalizedGroupStateColor
     */
    'r': number;
    /**
     * 
     * @type {number}
     * @memberof NormalizedGroupStateColor
     */
    'g': number;
    /**
     * 
     * @type {number}
     * @memberof NormalizedGroupStateColor
     */
    'b': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RF24Channel = {
    Low: 'LOW',
    Mid: 'MID',
    High: 'HIGH'
} as const;

export type RF24Channel = typeof RF24Channel[keyof typeof RF24Channel];


/**
 * 
 * @export
 * @interface RawCommandsRemoteTypePostRequest
 */
export interface RawCommandsRemoteTypePostRequest {
    /**
     * Raw packet to send
     * @type {string}
     * @memberof RawCommandsRemoteTypePostRequest
     */
    'packet'?: string;
    /**
     * Number of repeated packets to send
     * @type {number}
     * @memberof RawCommandsRemoteTypePostRequest
     */
    'num_repeats'?: number;
}
/**
 * 
 * @export
 * @interface ReadPacket
 */
export interface ReadPacket {
    /**
     * 
     * @type {string}
     * @memberof ReadPacket
     */
    'packet_info'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RemoteType = {
    Rgbw: 'rgbw',
    Cct: 'cct',
    RgbCct: 'rgb_cct',
    Rgb: 'rgb',
    Fut089: 'fut089',
    Fut091: 'fut091',
    Fut020: 'fut020'
} as const;

export type RemoteType = typeof RemoteType[keyof typeof RemoteType];


/**
 * 
 * @export
 * @interface Settings
 */
export interface Settings {
    /**
     * If spcified along with `admin_password`, HTTP basic auth will be enabled to access all REST endpoints.
     * @type {string}
     * @memberof Settings
     */
    'admin_username'?: string;
    /**
     * If spcified along with `admin_username`, HTTP basic auth will be enabled to access all REST endpoints.
     * @type {string}
     * @memberof Settings
     */
    'admin_password'?: string;
    /**
     * CE pin to use for SPI radio (nRF24, LT8900)
     * @type {number}
     * @memberof Settings
     */
    'ce_pin'?: number;
    /**
     * CSN pin to use with nRF24
     * @type {number}
     * @memberof Settings
     */
    'csn_pin'?: number;
    /**
     * Reset pin to use with LT8900
     * @type {number}
     * @memberof Settings
     */
    'reset_pin'?: number;
    /**
     * Pin to control for status LED.  Set to a negative value to invert on/off status.
     * @type {number}
     * @memberof Settings
     */
    'led_pin'?: number;
    /**
     * Number of times to resend the same 2.4 GHz milight packet when a command is sent.
     * @type {number}
     * @memberof Settings
     */
    'packet_repeats'?: number;
    /**
     * Packet repeats resulting from REST commands will be multiplied by this number.
     * @type {number}
     * @memberof Settings
     */
    'http_repeat_factor'?: number;
    /**
     * Automatically restart the device after the number of specified minutes.  Use 0 to disable.
     * @type {number}
     * @memberof Settings
     */
    'auto_restart_period'?: number;
    /**
     * MQTT server to connect to.
     * @type {string}
     * @memberof Settings
     */
    'mqtt_server'?: string;
    /**
     * If specified, use this username to authenticate with the MQTT server.
     * @type {string}
     * @memberof Settings
     */
    'mqtt_username'?: string;
    /**
     * If specified, use this password to authenticate with the MQTT server.
     * @type {string}
     * @memberof Settings
     */
    'mqtt_password'?: string;
    /**
     * Topic pattern to listen on for commands.  More detail on the format in README.
     * @type {string}
     * @memberof Settings
     */
    'mqtt_topic_pattern'?: string;
    /**
     * Topic pattern individual intercepted commands will be sent to.  More detail on the format in README.
     * @type {string}
     * @memberof Settings
     */
    'mqtt_update_topic_pattern'?: string;
    /**
     * Topic pattern device state will be sent to.  More detail on the format in README.
     * @type {string}
     * @memberof Settings
     */
    'mqtt_update_state_pattern'?: string;
    /**
     * Topic client status will be sent to.
     * @type {string}
     * @memberof Settings
     */
    'mqtt_client_status_topic'?: string;
    /**
     * If true, will use a simple enum flag (`connected` or `disconnected`) to indicate status.  If false, will send a rich JSON message including IP address, version, etc.
     * @type {boolean}
     * @memberof Settings
     */
    'simple_mqtt_client_status'?: boolean;
    /**
     * UDP discovery port
     * @type {number}
     * @memberof Settings
     */
    'discovery_port'?: number;
    /**
     * Controls how many cycles are spent listening for packets.  Set to 0 to disable passive listening.
     * @type {number}
     * @memberof Settings
     */
    'listen_repeats'?: number;
    /**
     * Controls how many miliseconds must pass between states being flushed to persistent storage.  Set to 0 to disable throttling.
     * @type {number}
     * @memberof Settings
     */
    'state_flush_interval'?: number;
    /**
     * Controls how many miliseconds must pass between MQTT state updates.  Set to 0 to disable throttling.
     * @type {number}
     * @memberof Settings
     */
    'mqtt_state_rate_limit'?: number;
    /**
     * Controls how much time has to pass after the last status update was queued.
     * @type {number}
     * @memberof Settings
     */
    'mqtt_debounce_delay'?: number;
    /**
     * Controls how packet repeats are throttled.  Packets sent with less time (measured in milliseconds) between them than this value (in milliseconds) will cause packet repeats to be throttled down.  More than this value will unthrottle up.
     * @type {number}
     * @memberof Settings
     */
    'packet_repeat_throttle_threshold'?: number;
    /**
     * Controls how packet repeats are throttled. Higher values cause packets to be throttled up and down faster.  Set to 0 to disable throttling.
     * @type {number}
     * @memberof Settings
     */
    'packet_repeat_throttle_sensitivity'?: number;
    /**
     * Controls how far throttling can decrease the number of repeated packets
     * @type {number}
     * @memberof Settings
     */
    'packet_repeat_minimum'?: number;
    /**
     * When making updates to hue or white temperature in a different bulb mode, switch back to the original bulb mode after applying the setting change.
     * @type {boolean}
     * @memberof Settings
     */
    'enable_automatic_mode_switching'?: boolean;
    /**
     * 
     * @type {LedMode}
     * @memberof Settings
     */
    'led_mode_wifi_config'?: LedMode;
    /**
     * 
     * @type {LedMode}
     * @memberof Settings
     */
    'led_mode_wifi_failed'?: LedMode;
    /**
     * 
     * @type {LedMode}
     * @memberof Settings
     */
    'led_mode_operating'?: LedMode;
    /**
     * 
     * @type {LedMode}
     * @memberof Settings
     */
    'led_mode_packet'?: LedMode;
    /**
     * Number of times the LED will flash when packets are changing
     * @type {number}
     * @memberof Settings
     */
    'led_mode_packet_count'?: number;
    /**
     * Hostname that will be advertized on a DHCP request
     * @type {string}
     * @memberof Settings
     */
    'hostname'?: string;
    /**
     * Power level used when packets are sent.  See nRF24 documentation for further detail.
     * @type {string}
     * @memberof Settings
     */
    'rf24_power_level'?: SettingsRf24PowerLevelEnum;
    /**
     * 
     * @type {RF24Channel}
     * @memberof Settings
     */
    'rf24_listen_channel'?: RF24Channel;
    /**
     * If specified, the static IP address to use
     * @type {string}
     * @memberof Settings
     */
    'wifi_static_ip'?: string;
    /**
     * If specified along with static IP, the gateway address to use
     * @type {string}
     * @memberof Settings
     */
    'wifi_static_ip_gateway'?: string;
    /**
     * If specified along with static IP, the netmask to use
     * @type {string}
     * @memberof Settings
     */
    'wifi_static_ip_netmask'?: string;
    /**
     * Packets are sent asynchronously.  This number controls the number of repeats sent during each iteration.  Increase this number to improve packet throughput.  Decrease to improve system multi-tasking.
     * @type {number}
     * @memberof Settings
     */
    'packet_repeats_per_loop'?: number;
    /**
     * If specified along with MQTT settings, will enable HomeAssistant MQTT discovery using the specified discovery prefix.  HomeAssistant\'s default is `homeassistant/`.
     * @type {string}
     * @memberof Settings
     */
    'home_assistant_discovery_prefix'?: string;
    /**
     * Forces WiFi into the spcified mode.  Try using B or G mode if you are having stability issues.
     * @type {string}
     * @memberof Settings
     */
    'wifi_mode'?: SettingsWifiModeEnum;
    /**
     * Defines which channels we send on.  Each remote type has three channels.  We can send on any subset of these.
     * @type {Array<RF24Channel>}
     * @memberof Settings
     */
    'rf24_channels'?: Array<RF24Channel>;
    /**
     * List of saved device IDs, stored as 3-long arrays.  Elements are: 1) remote ID, 2) remote type, 3) group ID
     * @type {Array<Array<any>>}
     * @memberof Settings
     */
    'device_ids'?: Array<Array<any>>;
    /**
     * List of UDP servers, stored as 3-long arrays.  Elements are 1) remote ID to bind to, 2) UDP port to listen on, 3) protocol version (5 or 6)
     * @type {Array<number>}
     * @memberof Settings
     */
    'gateway_configs'?: Array<number>;
    /**
     * 
     * @type {Array<GroupStateField>}
     * @memberof Settings
     */
    'group_state_fields'?: Array<GroupStateField>;
    /**
     * DEPRECATED (use /aliases routes instead)  Keys are aliases, values are 3-long arrays with same schema as items in `device_ids`. 
     * @type {object}
     * @memberof Settings
     * @deprecated
     */
    'group_id_aliases'?: object;
    /**
     * Default number of milliseconds between transition packets.  Set this value lower for more granular transitions, or higher if you are having performance issues during transitions. 
     * @type {number}
     * @memberof Settings
     */
    'default_transition_period'?: number;
}

export const SettingsRf24PowerLevelEnum = {
    Min: 'MIN',
    Low: 'LOW',
    High: 'HIGH',
    Max: 'MAX'
} as const;

export type SettingsRf24PowerLevelEnum = typeof SettingsRf24PowerLevelEnum[keyof typeof SettingsRf24PowerLevelEnum];
export const SettingsWifiModeEnum = {
    B: 'B',
    G: 'G',
    N: 'N'
} as const;

export type SettingsWifiModeEnum = typeof SettingsWifiModeEnum[keyof typeof SettingsWifiModeEnum];

/**
 * On/Off state
 * @export
 * @enum {string}
 */

export const State = {
    On: 'ON',
    Off: 'OFF'
} as const;

export type State = typeof State[keyof typeof State];


/**
 * 
 * @export
 * @interface SystemPostRequest
 */
export interface SystemPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SystemPostRequest
     */
    'command': SystemPostRequestCommandEnum;
}

export const SystemPostRequestCommandEnum = {
    Restart: 'restart',
    ClearWifiConfig: 'clear_wifi_config'
} as const;

export type SystemPostRequestCommandEnum = typeof SystemPostRequestCommandEnum[keyof typeof SystemPostRequestCommandEnum];

/**
 * 
 * @export
 * @interface TransitionArgs
 */
export interface TransitionArgs {
    /**
     * 
     * @type {TransitionField}
     * @memberof TransitionArgs
     */
    'field'?: TransitionField;
    /**
     * 
     * @type {TransitionValue}
     * @memberof TransitionArgs
     */
    'start_value'?: TransitionValue;
    /**
     * 
     * @type {TransitionValue}
     * @memberof TransitionArgs
     */
    'end_value'?: TransitionValue;
    /**
     * Duration of transition, measured in seconds
     * @type {number}
     * @memberof TransitionArgs
     */
    'duration'?: number;
    /**
     * Length of time between updates in a transition, measured in milliseconds
     * @type {number}
     * @memberof TransitionArgs
     */
    'period'?: number;
}


/**
 * 
 * @export
 * @interface TransitionData
 */
export interface TransitionData {
    /**
     * 
     * @type {TransitionField}
     * @memberof TransitionData
     */
    'field'?: TransitionField;
    /**
     * 
     * @type {TransitionValue}
     * @memberof TransitionData
     */
    'start_value'?: TransitionValue;
    /**
     * 
     * @type {TransitionValue}
     * @memberof TransitionData
     */
    'end_value'?: TransitionValue;
    /**
     * Duration of transition, measured in seconds
     * @type {number}
     * @memberof TransitionData
     */
    'duration'?: number;
    /**
     * Length of time between updates in a transition, measured in milliseconds
     * @type {number}
     * @memberof TransitionData
     */
    'period'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransitionData
     */
    'id'?: number;
    /**
     * Timestamp since last update was sent.
     * @type {number}
     * @memberof TransitionData
     */
    'last_sent'?: number;
    /**
     * 
     * @type {BulbId}
     * @memberof TransitionData
     */
    'bulb'?: BulbId;
    /**
     * Specifies whether this is a simple field transition, or a color transition. 
     * @type {string}
     * @memberof TransitionData
     */
    'type'?: TransitionDataTypeEnum;
    /**
     * 
     * @type {TransitionValue}
     * @memberof TransitionData
     */
    'current_value'?: TransitionValue;
}

export const TransitionDataTypeEnum = {
    Field: 'field',
    Color: 'color'
} as const;

export type TransitionDataTypeEnum = typeof TransitionDataTypeEnum[keyof typeof TransitionDataTypeEnum];

/**
 * If transitioning `status`: * If transitioning to `OFF`, will fade to 0 brightness and then turn off. * If transitioning to `ON`, will turn on, set brightness to 0, and fade to brightness 100. 
 * @export
 * @enum {string}
 */

export const TransitionField = {
    Hue: 'hue',
    Saturation: 'saturation',
    Brightness: 'brightness',
    Level: 'level',
    Kelvin: 'kelvin',
    ColorTemp: 'color_temp',
    Color: 'color',
    Status: 'status'
} as const;

export type TransitionField = typeof TransitionField[keyof typeof TransitionField];


/**
 * @type TransitionValue
 * Either an int value or a color
 * @export
 */
export type TransitionValue = number | string;

/**
 * 
 * @export
 * @interface TransitionsPostRequest
 */
export interface TransitionsPostRequest {
    /**
     * 
     * @type {TransitionField}
     * @memberof TransitionsPostRequest
     */
    'field'?: TransitionField;
    /**
     * 
     * @type {TransitionValue}
     * @memberof TransitionsPostRequest
     */
    'start_value'?: TransitionValue;
    /**
     * 
     * @type {TransitionValue}
     * @memberof TransitionsPostRequest
     */
    'end_value'?: TransitionValue;
    /**
     * Duration of transition, measured in seconds
     * @type {number}
     * @memberof TransitionsPostRequest
     */
    'duration'?: number;
    /**
     * Length of time between updates in a transition, measured in milliseconds
     * @type {number}
     * @memberof TransitionsPostRequest
     */
    'period'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransitionsPostRequest
     */
    'id'?: number;
    /**
     * Timestamp since last update was sent.
     * @type {number}
     * @memberof TransitionsPostRequest
     */
    'last_sent'?: number;
    /**
     * 
     * @type {BulbId}
     * @memberof TransitionsPostRequest
     */
    'bulb'?: BulbId;
    /**
     * Specifies whether this is a simple field transition, or a color transition. 
     * @type {string}
     * @memberof TransitionsPostRequest
     */
    'type'?: TransitionsPostRequestTypeEnum;
    /**
     * 
     * @type {TransitionValue}
     * @memberof TransitionsPostRequest
     */
    'current_value'?: TransitionValue;
    /**
     * 
     * @type {number}
     * @memberof TransitionsPostRequest
     */
    'device_id': number;
    /**
     * 
     * @type {number}
     * @memberof TransitionsPostRequest
     */
    'group_id': number;
    /**
     * 
     * @type {RemoteType}
     * @memberof TransitionsPostRequest
     */
    'device_type': RemoteType;
}

export const TransitionsPostRequestTypeEnum = {
    Field: 'field',
    Color: 'color'
} as const;

export type TransitionsPostRequestTypeEnum = typeof TransitionsPostRequestTypeEnum[keyof typeof TransitionsPostRequestTypeEnum];


/**
 * AliasesApi - axios parameter creator
 * @export
 */
export const AliasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Download a backup of all aliases in a binary format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesBinGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aliases.bin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a backup of all aliases in CSV format
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesBinPost: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aliases.bin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an alias by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('aliasesIdDelete', 'id', id)
            const localVarPath = `/aliases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an alias by ID
         * @param {number} id 
         * @param {AliasesIdPutRequest} aliasesIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesIdPut: async (id: number, aliasesIdPutRequest: AliasesIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('aliasesIdPut', 'id', id)
            // verify required parameter 'aliasesIdPutRequest' is not null or undefined
            assertParamExists('aliasesIdPut', 'aliasesIdPutRequest', aliasesIdPutRequest)
            const localVarPath = `/aliases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aliasesIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new alias
         * @param {Alias} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesPost: async (alias: Alias, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('aliasesPost', 'alias', alias)
            const localVarPath = `/aliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alias, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AliasesApi - functional programming interface
 * @export
 */
export const AliasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AliasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Download a backup of all aliases in a binary format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aliasesBinGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aliasesBinGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AliasesApi.aliasesBinGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a backup of all aliases in CSV format
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aliasesBinPost(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aliasesBinPost(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AliasesApi.aliasesBinPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aliasesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AliasesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aliasesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AliasesApi.aliasesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an alias by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aliasesIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aliasesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AliasesApi.aliasesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an alias by ID
         * @param {number} id 
         * @param {AliasesIdPutRequest} aliasesIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aliasesIdPut(id: number, aliasesIdPutRequest: AliasesIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aliasesIdPut(id, aliasesIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AliasesApi.aliasesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new alias
         * @param {Alias} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aliasesPost(alias: Alias, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AliasesPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aliasesPost(alias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AliasesApi.aliasesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AliasesApi - factory interface
 * @export
 */
export const AliasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AliasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Download a backup of all aliases in a binary format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesBinGet(options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.aliasesBinGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a backup of all aliases in CSV format
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesBinPost(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.aliasesBinPost(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesGet(options?: RawAxiosRequestConfig): AxiosPromise<AliasesGet200Response> {
            return localVarFp.aliasesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an alias by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.aliasesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an alias by ID
         * @param {number} id 
         * @param {AliasesIdPutRequest} aliasesIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesIdPut(id: number, aliasesIdPutRequest: AliasesIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.aliasesIdPut(id, aliasesIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new alias
         * @param {Alias} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasesPost(alias: Alias, options?: RawAxiosRequestConfig): AxiosPromise<AliasesPost201Response> {
            return localVarFp.aliasesPost(alias, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AliasesApi - object-oriented interface
 * @export
 * @class AliasesApi
 * @extends {BaseAPI}
 */
export class AliasesApi extends BaseAPI {
    /**
     * 
     * @summary Download a backup of all aliases in a binary format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public aliasesBinGet(options?: RawAxiosRequestConfig) {
        return AliasesApiFp(this.configuration).aliasesBinGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a backup of all aliases in CSV format
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public aliasesBinPost(file?: File, options?: RawAxiosRequestConfig) {
        return AliasesApiFp(this.configuration).aliasesBinPost(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public aliasesGet(options?: RawAxiosRequestConfig) {
        return AliasesApiFp(this.configuration).aliasesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an alias by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public aliasesIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return AliasesApiFp(this.configuration).aliasesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an alias by ID
     * @param {number} id 
     * @param {AliasesIdPutRequest} aliasesIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public aliasesIdPut(id: number, aliasesIdPutRequest: AliasesIdPutRequest, options?: RawAxiosRequestConfig) {
        return AliasesApiFp(this.configuration).aliasesIdPut(id, aliasesIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new alias
     * @param {Alias} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public aliasesPost(alias: Alias, options?: RawAxiosRequestConfig) {
        return AliasesApiFp(this.configuration).aliasesPost(alias, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeviceControlApi - axios parameter creator
 * @export
 */
export const DeviceControlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Usets all known values for state fields for the corresponding device.  If MQTT is configured, the retained state message corresponding to this device will also be deleted.
         * @summary Delete kept state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceIdRemoteTypeGroupIdDelete: async (deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdDelete', 'deviceId', deviceId)
            // verify required parameter 'remoteType' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdDelete', 'remoteType', remoteType)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdDelete', 'groupId', groupId)
            const localVarPath = `/gateways/{device-id}/{remote-type}/{group-id}`
                .replace(`{${"device-id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"remote-type"}}`, encodeURIComponent(String(remoteType)))
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If `blockOnQueue` is provided, a response will not be returned until any unprocessed packets in the command queue are finished sending.
         * @summary Get device state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceIdRemoteTypeGroupIdGet: async (deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, blockOnQueue?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdGet', 'deviceId', deviceId)
            // verify required parameter 'remoteType' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdGet', 'remoteType', remoteType)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdGet', 'groupId', groupId)
            const localVarPath = `/gateways/{device-id}/{remote-type}/{group-id}`
                .replace(`{${"device-id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"remote-type"}}`, encodeURIComponent(String(remoteType)))
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockOnQueue !== undefined) {
                localVarQueryParameter['blockOnQueue'] = blockOnQueue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update state of the bulbs with the provided parameters.  Existing parameters will be unchanged. if `blockOnQueue` is set to true, the response will not return until packets corresponding to the commands sent are processed, and the updated `GroupState` will be returned.  If `blockOnQueue` is false or not provided, a simple response indicating success will be returned. if `fmt` is set to `normalized`, the response will be in normalized format.
         * @summary Patch device state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum} [fmt] If set to &#x60;normalized&#x60;, the response will be in normalized format.
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutRequest} [gatewaysDeviceIdRemoteTypeGroupIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceIdRemoteTypeGroupIdPut: async (deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, blockOnQueue?: boolean, fmt?: GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum, gatewaysDeviceIdRemoteTypeGroupIdPutRequest?: GatewaysDeviceIdRemoteTypeGroupIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdPut', 'deviceId', deviceId)
            // verify required parameter 'remoteType' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdPut', 'remoteType', remoteType)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('gatewaysDeviceIdRemoteTypeGroupIdPut', 'groupId', groupId)
            const localVarPath = `/gateways/{device-id}/{remote-type}/{group-id}`
                .replace(`{${"device-id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"remote-type"}}`, encodeURIComponent(String(remoteType)))
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockOnQueue !== undefined) {
                localVarQueryParameter['blockOnQueue'] = blockOnQueue;
            }

            if (fmt !== undefined) {
                localVarQueryParameter['fmt'] = fmt;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gatewaysDeviceIdRemoteTypeGroupIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a dump of all aliases and their current states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gateways`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceControlApi - functional programming interface
 * @export
 */
export const DeviceControlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceControlApiAxiosParamCreator(configuration)
    return {
        /**
         * Usets all known values for state fields for the corresponding device.  If MQTT is configured, the retained state message corresponding to this device will also be deleted.
         * @summary Delete kept state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewaysDeviceIdRemoteTypeGroupIdDelete(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewaysDeviceIdRemoteTypeGroupIdDelete(deviceId, remoteType, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceControlApi.gatewaysDeviceIdRemoteTypeGroupIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If `blockOnQueue` is provided, a response will not be returned until any unprocessed packets in the command queue are finished sending.
         * @summary Get device state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewaysDeviceIdRemoteTypeGroupIdGet(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, blockOnQueue?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewaysDeviceIdRemoteTypeGroupIdGet(deviceId, remoteType, groupId, blockOnQueue, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceControlApi.gatewaysDeviceIdRemoteTypeGroupIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update state of the bulbs with the provided parameters.  Existing parameters will be unchanged. if `blockOnQueue` is set to true, the response will not return until packets corresponding to the commands sent are processed, and the updated `GroupState` will be returned.  If `blockOnQueue` is false or not provided, a simple response indicating success will be returned. if `fmt` is set to `normalized`, the response will be in normalized format.
         * @summary Patch device state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum} [fmt] If set to &#x60;normalized&#x60;, the response will be in normalized format.
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutRequest} [gatewaysDeviceIdRemoteTypeGroupIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewaysDeviceIdRemoteTypeGroupIdPut(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, blockOnQueue?: boolean, fmt?: GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum, gatewaysDeviceIdRemoteTypeGroupIdPutRequest?: GatewaysDeviceIdRemoteTypeGroupIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewaysDeviceIdRemoteTypeGroupIdPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewaysDeviceIdRemoteTypeGroupIdPut(deviceId, remoteType, groupId, blockOnQueue, fmt, gatewaysDeviceIdRemoteTypeGroupIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceControlApi.gatewaysDeviceIdRemoteTypeGroupIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a dump of all aliases and their current states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewaysGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GatewayListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewaysGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceControlApi.gatewaysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeviceControlApi - factory interface
 * @export
 */
export const DeviceControlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceControlApiFp(configuration)
    return {
        /**
         * Usets all known values for state fields for the corresponding device.  If MQTT is configured, the retained state message corresponding to this device will also be deleted.
         * @summary Delete kept state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceIdRemoteTypeGroupIdDelete(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.gatewaysDeviceIdRemoteTypeGroupIdDelete(deviceId, remoteType, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * If `blockOnQueue` is provided, a response will not be returned until any unprocessed packets in the command queue are finished sending.
         * @summary Get device state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceIdRemoteTypeGroupIdGet(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, blockOnQueue?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GroupState> {
            return localVarFp.gatewaysDeviceIdRemoteTypeGroupIdGet(deviceId, remoteType, groupId, blockOnQueue, options).then((request) => request(axios, basePath));
        },
        /**
         * Update state of the bulbs with the provided parameters.  Existing parameters will be unchanged. if `blockOnQueue` is set to true, the response will not return until packets corresponding to the commands sent are processed, and the updated `GroupState` will be returned.  If `blockOnQueue` is false or not provided, a simple response indicating success will be returned. if `fmt` is set to `normalized`, the response will be in normalized format.
         * @summary Patch device state
         * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum} [fmt] If set to &#x60;normalized&#x60;, the response will be in normalized format.
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutRequest} [gatewaysDeviceIdRemoteTypeGroupIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceIdRemoteTypeGroupIdPut(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, blockOnQueue?: boolean, fmt?: GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum, gatewaysDeviceIdRemoteTypeGroupIdPutRequest?: GatewaysDeviceIdRemoteTypeGroupIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<GatewaysDeviceIdRemoteTypeGroupIdPut200Response> {
            return localVarFp.gatewaysDeviceIdRemoteTypeGroupIdPut(deviceId, remoteType, groupId, blockOnQueue, fmt, gatewaysDeviceIdRemoteTypeGroupIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a dump of all aliases and their current states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<GatewayListItem>> {
            return localVarFp.gatewaysGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceControlApi - object-oriented interface
 * @export
 * @class DeviceControlApi
 * @extends {BaseAPI}
 */
export class DeviceControlApi extends BaseAPI {
    /**
     * Usets all known values for state fields for the corresponding device.  If MQTT is configured, the retained state message corresponding to this device will also be deleted.
     * @summary Delete kept state
     * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
     * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
     * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControlApi
     */
    public gatewaysDeviceIdRemoteTypeGroupIdDelete(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, options?: RawAxiosRequestConfig) {
        return DeviceControlApiFp(this.configuration).gatewaysDeviceIdRemoteTypeGroupIdDelete(deviceId, remoteType, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If `blockOnQueue` is provided, a response will not be returned until any unprocessed packets in the command queue are finished sending.
     * @summary Get device state
     * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
     * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
     * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
     * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControlApi
     */
    public gatewaysDeviceIdRemoteTypeGroupIdGet(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, blockOnQueue?: boolean, options?: RawAxiosRequestConfig) {
        return DeviceControlApiFp(this.configuration).gatewaysDeviceIdRemoteTypeGroupIdGet(deviceId, remoteType, groupId, blockOnQueue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update state of the bulbs with the provided parameters.  Existing parameters will be unchanged. if `blockOnQueue` is set to true, the response will not return until packets corresponding to the commands sent are processed, and the updated `GroupState` will be returned.  If `blockOnQueue` is false or not provided, a simple response indicating success will be returned. if `fmt` is set to `normalized`, the response will be in normalized format.
     * @summary Patch device state
     * @param {GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter} deviceId 2-byte device ID.  Can be decimal or hexadecimal.
     * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
     * @param {number} groupId Group ID.  Should be 0-8, depending on remote type.  Group 0 is a \&quot;wildcard\&quot; group.  All bulbs paired with the same device ID will respond to commands sent to Group 0. 
     * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
     * @param {GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum} [fmt] If set to &#x60;normalized&#x60;, the response will be in normalized format.
     * @param {GatewaysDeviceIdRemoteTypeGroupIdPutRequest} [gatewaysDeviceIdRemoteTypeGroupIdPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControlApi
     */
    public gatewaysDeviceIdRemoteTypeGroupIdPut(deviceId: GatewaysDeviceIdRemoteTypeGroupIdGetDeviceIdParameter, remoteType: RemoteType, groupId: number, blockOnQueue?: boolean, fmt?: GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum, gatewaysDeviceIdRemoteTypeGroupIdPutRequest?: GatewaysDeviceIdRemoteTypeGroupIdPutRequest, options?: RawAxiosRequestConfig) {
        return DeviceControlApiFp(this.configuration).gatewaysDeviceIdRemoteTypeGroupIdPut(deviceId, remoteType, groupId, blockOnQueue, fmt, gatewaysDeviceIdRemoteTypeGroupIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a dump of all aliases and their current states
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControlApi
     */
    public gatewaysGet(options?: RawAxiosRequestConfig) {
        return DeviceControlApiFp(this.configuration).gatewaysGet(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum = {
    Normalized: 'normalized'
} as const;
export type GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum = typeof GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum[keyof typeof GatewaysDeviceIdRemoteTypeGroupIdPutFmtEnum];


/**
 * DeviceControlByAliasApi - axios parameter creator
 * @export
 */
export const DeviceControlByAliasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Usets all known values for state fields for the corresponding device.  If MQTT is configured, the retained state message corresponding to this device will also be deleted.
         * @summary Delete kept state for alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceAliasDelete: async (deviceAlias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceAlias' is not null or undefined
            assertParamExists('gatewaysDeviceAliasDelete', 'deviceAlias', deviceAlias)
            const localVarPath = `/gateways/{device-alias}`
                .replace(`{${"device-alias"}}`, encodeURIComponent(String(deviceAlias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get device state by alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceAliasGet: async (deviceAlias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceAlias' is not null or undefined
            assertParamExists('gatewaysDeviceAliasGet', 'deviceAlias', deviceAlias)
            const localVarPath = `/gateways/{device-alias}`
                .replace(`{${"device-alias"}}`, encodeURIComponent(String(deviceAlias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch device state by alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {GatewaysDeviceAliasPutFmtEnum} [fmt] If set to &#x60;normalized&#x60;, the response will be in normalized format.
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutRequest} [gatewaysDeviceIdRemoteTypeGroupIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceAliasPut: async (deviceAlias: string, blockOnQueue?: boolean, fmt?: GatewaysDeviceAliasPutFmtEnum, gatewaysDeviceIdRemoteTypeGroupIdPutRequest?: GatewaysDeviceIdRemoteTypeGroupIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceAlias' is not null or undefined
            assertParamExists('gatewaysDeviceAliasPut', 'deviceAlias', deviceAlias)
            const localVarPath = `/gateways/{device-alias}`
                .replace(`{${"device-alias"}}`, encodeURIComponent(String(deviceAlias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockOnQueue !== undefined) {
                localVarQueryParameter['blockOnQueue'] = blockOnQueue;
            }

            if (fmt !== undefined) {
                localVarQueryParameter['fmt'] = fmt;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gatewaysDeviceIdRemoteTypeGroupIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceControlByAliasApi - functional programming interface
 * @export
 */
export const DeviceControlByAliasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceControlByAliasApiAxiosParamCreator(configuration)
    return {
        /**
         * Usets all known values for state fields for the corresponding device.  If MQTT is configured, the retained state message corresponding to this device will also be deleted.
         * @summary Delete kept state for alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewaysDeviceAliasDelete(deviceAlias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewaysDeviceAliasDelete(deviceAlias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceControlByAliasApi.gatewaysDeviceAliasDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get device state by alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewaysDeviceAliasGet(deviceAlias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewaysDeviceAliasGet(deviceAlias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceControlByAliasApi.gatewaysDeviceAliasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch device state by alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {GatewaysDeviceAliasPutFmtEnum} [fmt] If set to &#x60;normalized&#x60;, the response will be in normalized format.
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutRequest} [gatewaysDeviceIdRemoteTypeGroupIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewaysDeviceAliasPut(deviceAlias: string, blockOnQueue?: boolean, fmt?: GatewaysDeviceAliasPutFmtEnum, gatewaysDeviceIdRemoteTypeGroupIdPutRequest?: GatewaysDeviceIdRemoteTypeGroupIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewaysDeviceIdRemoteTypeGroupIdPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewaysDeviceAliasPut(deviceAlias, blockOnQueue, fmt, gatewaysDeviceIdRemoteTypeGroupIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceControlByAliasApi.gatewaysDeviceAliasPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeviceControlByAliasApi - factory interface
 * @export
 */
export const DeviceControlByAliasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceControlByAliasApiFp(configuration)
    return {
        /**
         * Usets all known values for state fields for the corresponding device.  If MQTT is configured, the retained state message corresponding to this device will also be deleted.
         * @summary Delete kept state for alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceAliasDelete(deviceAlias: string, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.gatewaysDeviceAliasDelete(deviceAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get device state by alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceAliasGet(deviceAlias: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupState> {
            return localVarFp.gatewaysDeviceAliasGet(deviceAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch device state by alias
         * @param {string} deviceAlias Device alias saved in settings
         * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
         * @param {GatewaysDeviceAliasPutFmtEnum} [fmt] If set to &#x60;normalized&#x60;, the response will be in normalized format.
         * @param {GatewaysDeviceIdRemoteTypeGroupIdPutRequest} [gatewaysDeviceIdRemoteTypeGroupIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaysDeviceAliasPut(deviceAlias: string, blockOnQueue?: boolean, fmt?: GatewaysDeviceAliasPutFmtEnum, gatewaysDeviceIdRemoteTypeGroupIdPutRequest?: GatewaysDeviceIdRemoteTypeGroupIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<GatewaysDeviceIdRemoteTypeGroupIdPut200Response> {
            return localVarFp.gatewaysDeviceAliasPut(deviceAlias, blockOnQueue, fmt, gatewaysDeviceIdRemoteTypeGroupIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceControlByAliasApi - object-oriented interface
 * @export
 * @class DeviceControlByAliasApi
 * @extends {BaseAPI}
 */
export class DeviceControlByAliasApi extends BaseAPI {
    /**
     * Usets all known values for state fields for the corresponding device.  If MQTT is configured, the retained state message corresponding to this device will also be deleted.
     * @summary Delete kept state for alias
     * @param {string} deviceAlias Device alias saved in settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControlByAliasApi
     */
    public gatewaysDeviceAliasDelete(deviceAlias: string, options?: RawAxiosRequestConfig) {
        return DeviceControlByAliasApiFp(this.configuration).gatewaysDeviceAliasDelete(deviceAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get device state by alias
     * @param {string} deviceAlias Device alias saved in settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControlByAliasApi
     */
    public gatewaysDeviceAliasGet(deviceAlias: string, options?: RawAxiosRequestConfig) {
        return DeviceControlByAliasApiFp(this.configuration).gatewaysDeviceAliasGet(deviceAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch device state by alias
     * @param {string} deviceAlias Device alias saved in settings
     * @param {boolean} [blockOnQueue] If true, response will block on update packets being sent before returning
     * @param {GatewaysDeviceAliasPutFmtEnum} [fmt] If set to &#x60;normalized&#x60;, the response will be in normalized format.
     * @param {GatewaysDeviceIdRemoteTypeGroupIdPutRequest} [gatewaysDeviceIdRemoteTypeGroupIdPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControlByAliasApi
     */
    public gatewaysDeviceAliasPut(deviceAlias: string, blockOnQueue?: boolean, fmt?: GatewaysDeviceAliasPutFmtEnum, gatewaysDeviceIdRemoteTypeGroupIdPutRequest?: GatewaysDeviceIdRemoteTypeGroupIdPutRequest, options?: RawAxiosRequestConfig) {
        return DeviceControlByAliasApiFp(this.configuration).gatewaysDeviceAliasPut(deviceAlias, blockOnQueue, fmt, gatewaysDeviceIdRemoteTypeGroupIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GatewaysDeviceAliasPutFmtEnum = {
    Normalized: 'normalized'
} as const;
export type GatewaysDeviceAliasPutFmtEnum = typeof GatewaysDeviceAliasPutFmtEnum[keyof typeof GatewaysDeviceAliasPutFmtEnum];


/**
 * RawPacketHandlingApi - axios parameter creator
 * @export
 */
export const RawPacketHandlingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read a packet from any remote type.  Does not return a response until a packet is read.
         * @summary Read a packet from any remote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayTrafficGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gateway_traffic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a packet from the given remote type.  Does not return a response until a packet is read. If `remote-type` is unspecified, will read from all remote types simultaneously.
         * @summary Read a packet from a specific remote
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayTrafficRemoteTypeGet: async (remoteType: RemoteType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'remoteType' is not null or undefined
            assertParamExists('gatewayTrafficRemoteTypeGet', 'remoteType', remoteType)
            const localVarPath = `/gateway_traffic/{remote-type}`
                .replace(`{${"remote-type"}}`, encodeURIComponent(String(remoteType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a raw packet
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {RawCommandsRemoteTypePostRequest} [rawCommandsRemoteTypePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawCommandsRemoteTypePost: async (remoteType: RemoteType, rawCommandsRemoteTypePostRequest?: RawCommandsRemoteTypePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'remoteType' is not null or undefined
            assertParamExists('rawCommandsRemoteTypePost', 'remoteType', remoteType)
            const localVarPath = `/raw_commands/{remote-type}`
                .replace(`{${"remote-type"}}`, encodeURIComponent(String(remoteType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rawCommandsRemoteTypePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RawPacketHandlingApi - functional programming interface
 * @export
 */
export const RawPacketHandlingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RawPacketHandlingApiAxiosParamCreator(configuration)
    return {
        /**
         * Read a packet from any remote type.  Does not return a response until a packet is read.
         * @summary Read a packet from any remote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayTrafficGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadPacket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayTrafficGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RawPacketHandlingApi.gatewayTrafficGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a packet from the given remote type.  Does not return a response until a packet is read. If `remote-type` is unspecified, will read from all remote types simultaneously.
         * @summary Read a packet from a specific remote
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayTrafficRemoteTypeGet(remoteType: RemoteType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadPacket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayTrafficRemoteTypeGet(remoteType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RawPacketHandlingApi.gatewayTrafficRemoteTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send a raw packet
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {RawCommandsRemoteTypePostRequest} [rawCommandsRemoteTypePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rawCommandsRemoteTypePost(remoteType: RemoteType, rawCommandsRemoteTypePostRequest?: RawCommandsRemoteTypePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rawCommandsRemoteTypePost(remoteType, rawCommandsRemoteTypePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RawPacketHandlingApi.rawCommandsRemoteTypePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RawPacketHandlingApi - factory interface
 * @export
 */
export const RawPacketHandlingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RawPacketHandlingApiFp(configuration)
    return {
        /**
         * Read a packet from any remote type.  Does not return a response until a packet is read.
         * @summary Read a packet from any remote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayTrafficGet(options?: RawAxiosRequestConfig): AxiosPromise<ReadPacket> {
            return localVarFp.gatewayTrafficGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Read a packet from the given remote type.  Does not return a response until a packet is read. If `remote-type` is unspecified, will read from all remote types simultaneously.
         * @summary Read a packet from a specific remote
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayTrafficRemoteTypeGet(remoteType: RemoteType, options?: RawAxiosRequestConfig): AxiosPromise<ReadPacket> {
            return localVarFp.gatewayTrafficRemoteTypeGet(remoteType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a raw packet
         * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
         * @param {RawCommandsRemoteTypePostRequest} [rawCommandsRemoteTypePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawCommandsRemoteTypePost(remoteType: RemoteType, rawCommandsRemoteTypePostRequest?: RawCommandsRemoteTypePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.rawCommandsRemoteTypePost(remoteType, rawCommandsRemoteTypePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RawPacketHandlingApi - object-oriented interface
 * @export
 * @class RawPacketHandlingApi
 * @extends {BaseAPI}
 */
export class RawPacketHandlingApi extends BaseAPI {
    /**
     * Read a packet from any remote type.  Does not return a response until a packet is read.
     * @summary Read a packet from any remote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawPacketHandlingApi
     */
    public gatewayTrafficGet(options?: RawAxiosRequestConfig) {
        return RawPacketHandlingApiFp(this.configuration).gatewayTrafficGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a packet from the given remote type.  Does not return a response until a packet is read. If `remote-type` is unspecified, will read from all remote types simultaneously.
     * @summary Read a packet from a specific remote
     * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawPacketHandlingApi
     */
    public gatewayTrafficRemoteTypeGet(remoteType: RemoteType, options?: RawAxiosRequestConfig) {
        return RawPacketHandlingApiFp(this.configuration).gatewayTrafficRemoteTypeGet(remoteType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a raw packet
     * @param {RemoteType} remoteType Type of remote to read a packet from.  If unspecified, will read packets from all remote types.
     * @param {RawCommandsRemoteTypePostRequest} [rawCommandsRemoteTypePostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawPacketHandlingApi
     */
    public rawCommandsRemoteTypePost(remoteType: RemoteType, rawCommandsRemoteTypePostRequest?: RawCommandsRemoteTypePostRequest, options?: RawAxiosRequestConfig) {
        return RawPacketHandlingApiFp(this.configuration).rawCommandsRemoteTypePost(remoteType, rawCommandsRemoteTypePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get existing settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Overwrite existing settings with a file
         * @param {Settings} [settings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPost: async (settings?: Settings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch existing settings
         * @param {Settings} [settings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPut: async (settings?: Settings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get existing settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Settings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Overwrite existing settings with a file
         * @param {Settings} [settings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsPost(settings?: Settings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsPost(settings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch existing settings
         * @param {Settings} [settings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsPut(settings?: Settings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsPut(settings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get existing settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsGet(options?: RawAxiosRequestConfig): AxiosPromise<Settings> {
            return localVarFp.settingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Overwrite existing settings with a file
         * @param {Settings} [settings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPost(settings?: Settings, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.settingsPost(settings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch existing settings
         * @param {Settings} [settings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPut(settings?: Settings, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.settingsPut(settings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get existing settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsGet(options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Overwrite existing settings with a file
     * @param {Settings} [settings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsPost(settings?: Settings, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsPost(settings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch existing settings
     * @param {Settings} [settings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsPut(settings?: Settings, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsPut(settings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aboutGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a backup of all settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a backup
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupPost: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update firmware
         * @param {File} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firmwarePost: async (fileName?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/firmware`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (fileName !== undefined) { 
                localVarFormParams.append('fileName', fileName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List supported remote types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remoteConfigsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/remote_configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send commands to the system.  Supported commands: 1. `restart`. Restart the ESP8266. 1. `clear_wifi_config`. Clears on-board wifi information. ESP8266 will reboot and enter wifi config mode. 
         * @summary Send a system command
         * @param {SystemPostRequest} [systemPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPost: async (systemPostRequest?: SystemPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aboutGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<About>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aboutGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.aboutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a backup of all settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backupGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backupGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.backupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a backup
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backupPost(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backupPost(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.backupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update firmware
         * @param {File} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firmwarePost(fileName?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firmwarePost(fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.firmwarePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List supported remote types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remoteConfigsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remoteConfigsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.remoteConfigsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send commands to the system.  Supported commands: 1. `restart`. Restart the ESP8266. 1. `clear_wifi_config`. Clears on-board wifi information. ESP8266 will reboot and enter wifi config mode. 
         * @summary Send a system command
         * @param {SystemPostRequest} [systemPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPost(systemPostRequest?: SystemPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPost(systemPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aboutGet(options?: RawAxiosRequestConfig): AxiosPromise<About> {
            return localVarFp.aboutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a backup of all settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupGet(options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.backupGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a backup
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupPost(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.backupPost(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update firmware
         * @param {File} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firmwarePost(fileName?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.firmwarePost(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List supported remote types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remoteConfigsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.remoteConfigsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Send commands to the system.  Supported commands: 1. `restart`. Restart the ESP8266. 1. `clear_wifi_config`. Clears on-board wifi information. ESP8266 will reboot and enter wifi config mode. 
         * @summary Send a system command
         * @param {SystemPostRequest} [systemPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPost(systemPostRequest?: SystemPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.systemPost(systemPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @summary Get system information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public aboutGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).aboutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a backup of all settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public backupGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).backupGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a backup
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public backupPost(file?: File, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).backupPost(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update firmware
     * @param {File} [fileName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public firmwarePost(fileName?: File, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).firmwarePost(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List supported remote types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public remoteConfigsGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).remoteConfigsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send commands to the system.  Supported commands: 1. `restart`. Restart the ESP8266. 1. `clear_wifi_config`. Clears on-board wifi information. ESP8266 will reboot and enter wifi config mode. 
     * @summary Send a system command
     * @param {SystemPostRequest} [systemPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemPost(systemPostRequest?: SystemPostRequest, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemPost(systemPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransitionsApi - axios parameter creator
 * @export
 */
export const TransitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all active transitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a transition
         * @param {number} id ID of transition.  This will be an auto-incrementing number reset after a restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transitionsIdDelete', 'id', id)
            const localVarPath = `/transitions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get properties for a transition
         * @param {number} id ID of transition.  This will be an auto-incrementing number reset after a restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transitionsIdGet', 'id', id)
            const localVarPath = `/transitions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new transition
         * @param {TransitionsPostRequest} [transitionsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionsPost: async (transitionsPostRequest?: TransitionsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transitionsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransitionsApi - functional programming interface
 * @export
 */
export const TransitionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all active transitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransitionData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransitionsApi.transitionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a transition
         * @param {number} id ID of transition.  This will be an auto-incrementing number reset after a restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransitionsApi.transitionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get properties for a transition
         * @param {number} id ID of transition.  This will be an auto-incrementing number reset after a restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransitionData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransitionsApi.transitionsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new transition
         * @param {TransitionsPostRequest} [transitionsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionsPost(transitionsPostRequest?: TransitionsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionsPost(transitionsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransitionsApi.transitionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransitionsApi - factory interface
 * @export
 */
export const TransitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransitionsApiFp(configuration)
    return {
        /**
         * 
         * @summary List all active transitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<TransitionData>> {
            return localVarFp.transitionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a transition
         * @param {number} id ID of transition.  This will be an auto-incrementing number reset after a restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.transitionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get properties for a transition
         * @param {number} id ID of transition.  This will be an auto-incrementing number reset after a restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<TransitionData> {
            return localVarFp.transitionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new transition
         * @param {TransitionsPostRequest} [transitionsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionsPost(transitionsPostRequest?: TransitionsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponse> {
            return localVarFp.transitionsPost(transitionsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransitionsApi - object-oriented interface
 * @export
 * @class TransitionsApi
 * @extends {BaseAPI}
 */
export class TransitionsApi extends BaseAPI {
    /**
     * 
     * @summary List all active transitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransitionsApi
     */
    public transitionsGet(options?: RawAxiosRequestConfig) {
        return TransitionsApiFp(this.configuration).transitionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a transition
     * @param {number} id ID of transition.  This will be an auto-incrementing number reset after a restart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransitionsApi
     */
    public transitionsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return TransitionsApiFp(this.configuration).transitionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get properties for a transition
     * @param {number} id ID of transition.  This will be an auto-incrementing number reset after a restart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransitionsApi
     */
    public transitionsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return TransitionsApiFp(this.configuration).transitionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new transition
     * @param {TransitionsPostRequest} [transitionsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransitionsApi
     */
    public transitionsPost(transitionsPostRequest?: TransitionsPostRequest, options?: RawAxiosRequestConfig) {
        return TransitionsApiFp(this.configuration).transitionsPost(transitionsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



